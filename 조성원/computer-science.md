## 네트워크

### 1. 네트워크에서 패킷이란 무엇을 의미하나요?

- 네트워크를 통해 전송되는 형식화된 데이터 블록
  - 사용자 데이터
    - 페이로드(payload)
    - 애플리케이션을 대신하여 전달되는 데이터
    - 가변 길이
      - 네트워크 프로토콜
      - 라우팅 장비
  - 제어 정보
    - 페이로드를 전달하기 위한 정보
    - 패킷 헤더와 푸터에서 발견됨
    - 홉 제한(TTL, Time To Live)
      - 패킷이 통과할 때마다 1씩 감소하는 필드
      - 홉 제한이 0에 도달하면 전송 작업이 실패하고 패킷이 삭제된다.
    - 오류 감지 및 수정
      - 순방향 오류 수정: 수신자가 자동으로 오류를 수정하는 오류 수정 코드를 사용하는 것
      - 역방향 오류 수정: 수신자가 발신자에게 전체 데이터 단위를 재전송하도록 요청하는 것
      - 패킷이 전송되기 전에 송신기에서 한 번 계산, 대상에서 수신되면 체크섬이 다시 계산되어 패킷의 체크섬과 비교
    - 우선순위
      - 높은 우선순위 대기열은 네트워크가 혼잡할 때 낮은 우선순위 대기열보다 더 빨리 비워진다.
    - 주소
      - 송신 호스트의 소스 주소
      - 수신 호스트의 대상 주소
- 패킷을 지원하지 않는 컴퓨터 통신 연결은 단순히 바이트, 문자열, 비트를 독립적으로 연속하여 데이터를 전송한다.
- 데이터가 패킷으로 형식이 바뀔 때, 네트워크는 장문 메시지를 더 효과적이고 신뢰성 있게 보낼 수 있다.

&nbsp;

### 2. 네트워크에서 처리량은 무엇을 의미하나요?

- 특정 시간 동안 실제로 네트워크를 통과할 수 있는 평균 데이터 양
- 목적지에서 성공적으로 도착한 데이터 패킷의 수와 데이터 패킷 손실을 나타낸다.
- 처리량에 영향을 미치는 요인
  - 대역폭
    - 네트워크 용량이 전송 매체의 최대 대역폭에 도달하면 처리량이 해당 제한을 초과할 수 없다.
  - 처리 능력
    - 처리 성능을 향상시키는 특수 하드웨어 또는 소프트웨어 최적화로 더 많은 양의 트래픽과 더 복잡한 패킷 처리 태스크를 처리할 수 있게 된다.
  - 패킷 손실
    - 패킷이 손실되면 다시 전송해야하므로, 지연이 발생하고 네트워크 전체 처리량이 감소한다.
  - 네트워크 토폴로지
    - 네트워크 디바이스 수, 네트워크 링크의 대역폭, 네트워크 경로의 디바이스 간 거리를 나타낸다.
    - 잘 설계된 네트워크 토폴로지는 데이터 전송을 위한 다중 경로를 제공하고 트래픽 병목 현상을 줄이며 처리량을 증가시킨다.

&nbsp;

### 3. 지연시간이란 무엇인가요?

- 네트워크를 통해 데이터를 전송하는 데 걸리는 시간
- 지연이나 랙이 길게 발생하는 네트워크는 지연 시간이 길고, 응답 시간이 빠른 네트워크는 지연 시간이 짧다.
- 네트워크 지연의 원인
  - 전송 매체
    - 지연 시간에 가장 큰 영향을 미친다.
      - 예시: 광섬유 네트워크가 무선 네트워크보다 빠르다.
  - 네트워크 트래픽 이동 거리
    - 네트워크 엔드포인트 간의 거리가 멀면 네트워크 지연 시간이 증가
  - 네트워크 홉 수
    - 중간 라우터가 여러 개인 경우 데이터 패킷에 필요한 홉 수가 증가하므로 네트워크 지연 시간 증가
  - 데이터 볼륨
    - 동시 데이터 볼륨이 많으면 네트워크 디바이스의 처리 용량이 제한될 수 있으므로 네트워크 지연 시간 증가
      - 예시: 인터넷과 같은 공유 네트워크 인프라 등
  - 서버 성능
    - 네트워크 문제가 아닌, 서버가 느리게 응답해서 생기는 지연

&nbsp;

### 4. 처리량은 어떤 상황에 영향을 받나요?

- 대역폭
  - 네트워크 용량이 전송 매체의 최대 대역폭에 도달하면 처리량이 해당 제한을 초과할 수 없다.
- 처리 능력
  - 처리 성능을 향상시키는 특수 하드웨어 또는 소프트웨어 최적화로 더 많은 양의 트래픽과 더 복잡한 패킷 처리 태스크를 처리할 수 있게 된다.
- 패킷 손실
  - 패킷이 손실되면 다시 전송해야하므로, 지연이 발생하고 네트워크 전체 처리량이 감소한다.
- 네트워크 토폴로지
  - 네트워크 디바이스 수, 네트워크 링크의 대역폭, 네트워크 경로의 디바이스 간 거리를 나타낸다.
  - 잘 설계된 네트워크 토폴로지는 데이터 전송을 위한 다중 경로를 제공하고 트래픽 병목 현상을 줄이며 처리량을 증가시킨다.

&nbsp;

### 5. 네트워크 병목현상은 무엇인가요?

![병목현상](./images/bottle_neck.jpg)

- 네트워크 내에서 데이터의 흐름이 한계에 도달하여 전송 속도가 더 이상 향상되지 않거나, 지연 현상이 발생하는 상황
- 네트워크 요소나 경로에서 가장 처리능력이 낮거나 대역폭이 작은 부분에서 발생할 수 있다.
- 병목현상의 원인을 찾을 때, 네트워크 토폴로지는 중요한 기준이 될 수 있다.

&nbsp;

### 6. TCP/IP 가 무엇인가요? 각 계층에 대해서 설명할 수 있나요?

#### TCP/IP

- 인터넷에서 컴퓨터들이 서로 정보를 주고받는 데 쓰이는 통신규약의 모음: The Internet Protocol Suite
  - OSI 7 Layer 중에서 Layer 3, Layer 4를 다루는 프로토콜
  - HTTP, TCP, IP 등이 속한다.
- 패킷 통신 방식의 인터넷 프로토콜인 IP와 전송 조절 프로토콜인 TCP로 구성
  - IP는 패킷 전달 여부와 순서를 보장하지 않는다.
  - TCP는 IP 위에서 동작하는 프로토콜로, 데이터의 전달과 순서를 보장한다.
- IP 주소 체계를 따라 IP Routing으로 목적지에 도달하며 TCP를 통해 신뢰성을 유지하겠다.
- TCP의 신뢰성 보장은 3-way handshake와 연관되어 있다.
  1. 클라이언트 → SYN → 서버
  2. 클라이언트 ← SYN + ACK ← 서버
  3. 클라이언트 → ACK → 서버

#### OSI 7 Layer

![네트워크 계층](./images/network_layer.webp)

1. 물리 계층
   - 전기적, 기계적, 기능적인 특성을 이용해 데이터를 전송
   - 통신 단위: 비트
   - 케이블, 리피터, 허브 등
2. 데이터 링크 계층
   - 물리 계층을 통해 송수신되는 정보의 오류와 흐름을 관리
   - 맥 주소를 가지고 통신
   - 통신 단위: 프레임
   - 브릿지, 스위치 등
3. 네트워크 계층
   - 데이터를 목적지까지 안전하고 빠르게 전달하는 기능(라우팅)
   - 경로 선택, 주소 결정, 패킷 전달
   - 통신 단위: 패킷
   - 라우터, L3 스위치 등
   - IP
4. 전송 계층
   - 신뢰성있는 데이터를 전송 보장
   - 오류검출 및 복구, 흐름제어, 중복 검사
   - 통신 단위: 세그먼트
   - L4 스위치 등
   - TCP, UDP
5. 세션 계층
   - 응용 프로세스가 통신을 관리하기 위한 방법 제공
   - 동시 송수신 방식(duplex), 반이중 방식(half-duplex), 전이중 방식(full-duplex) 통신
   - 체크 포인팅과 유휴, 종료, 재시작 등 수행
6. 표현 계층
   - 코드 간의 번역을 담당하여 데이터의 형식상 차이를 다루는 부담을 응용 계층으로부터 덜어준다.
   - 수신자 장치에서 적합한 애플리케이션을 사용해 송신자 장치로부터 온 데이터를 해석하기 위한 응용 계층 데이터 부호화, 변환
   - 수신자에서 압축을 풀 수 있는 방식으로 된 데이터 압축
   - 전송을 위한 암호화와 복호화
7. 응용 계층
   - 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행
   - FTP, HTTP, HTTPS, Telnet, SSH, SMTP, POP3, IMAP 등

&nbsp;

### 7. 전송 계층의 대표적인 방식은 무엇이 있고 어떤 차이가 있나요? (키워드: TCP, UDP)

#### TCP

- 연결 지향 방식 → 패킷 전송을 위한 논리적 경로를 배정
- 3-way handshake로 연결을 설정하고, 4-way handshake로 해제한다.
- 흐름 제어 및 혼잡 제어
- 1:1 통신
- 높은 신뢰성 보장
- UDP에 비해 느린 속도
- 전이중(full-duplex), 점대점(point-to-point) 방식

#### UDP

- 비연결형 서비스로 데이터그램 방식을 제공
- 정보를 보내거나 받는다는 신호 절차를 거치지 않는다.
- UDP 헤더의 checksum 필드를 통한 최소한의 오류 검출
- 1:1 or 1:N or N:N
- 낮은 신뢰성
- TCP에 비해 빠른 속도
- 신뢰성보다 연속성이 중요한 서비스에서 사용 (streaming)

&nbsp;

### 8. 계층 간 데이터 송수신 과정에 대해 설명할 수 있나요? (키워드: 캡슐화, 비캡슐화)

- 송신할 때 캡슐화, 수신할 때 비캡슐화

![캡슐화](./images/encapsulate.png)

- 송신(캡슐화) - TCP/IP 4계층의 관점에서 설명
  - 애플리케이션의 데이터가 애플리케이션 계층에서 전송 계층으로 이동하면서 TCP(L4) 헤더가 붙으며 세그먼트 또는 데이터그램화 된다.
  - 전송 계층에서 인터넷 계층으로 가면서 IP(L3) 헤더가 붙으며 패킷화 된다.
  - 인터넷 계층에서 링크 계층으로 가면서 프레임 헤더와 트레일러가 붙어 프레임화 된다.

![비캡슐화](./images/decapsulate.png)

- 수신(비캡슐화) - TCP/IP 4계층의 관점에서 설명
  - 링크 계층부터 타고 올라오면서 프레임화 → 패킷화 → 세그먼트 또는 데이터그램화 → 메시지화되어 최종적으로 사용자에게 애플리케이션의 PDU인 메시지로 전달된다.

&nbsp;

### 9. 네트워크에서 PDU에 대해 알고 있나요?

- 프로토콜 데이터 단위: 데이터 통신에서 상위 계층이 전달한 데이터에 붙이는 제어 정보
  - 층 1(물리 계층) PDU – 비트(스트림)
  - 층 2(데이터 링크 계층) PDU – 전달정보(프레임)
  - 층 3(네트워크 계층) PDU – 패킷 혹은 UDP의 데이터그램
  - 층 4(전송 계층) PDU – TCP 세그먼트
  - 층 5-6-7 (응용 계층) PDU – 메시지, 데이터

&nbsp;

### 10. 로드밸런서란 무엇인가요?

- 서버에 가해지는 부하(=로드)를 분산(=밸런싱)해주는 장치 또는 기술
- 클라이언트-서버 모델에서 클라이언트와 서버 사이에 위치
- 클라이언트 수가 굉장히 많아서 서버가 모든 클라이언트의 요청을 신속하게 처리하기가 힘들 때 적용할 수 있다.
  - Scale up: 서버 자체의 하드웨어 성능을 업그레이드하는 것
    - 서버 자체 성능을 업그레이드하는 것은 하드웨어라는 특성 상 한계가 존재
    - 나중에는 하드웨어를 업그레이드하는 비용이 서버 한 대를 추가하는 비용보다 비싸지는 특이점이 온다.
  - Scale out: 하나의 서버가 아닌 다수의 서버를 사용하는 것
    - 늘어난 모든 서버에 트래픽이 골고루 퍼질 수 있도록 해줘야 한다. → 로드 밸런싱
- 로드밸런싱 알고리즘
  - 라운드로빈: 서버에 들어온 요청을 순서대로 돌아가며 배정
  - IP 해시: 클라이언트 IP 주소를 특정 서버로 매핑해서 요청을 처리
  - 최소 연결: 요청이 들어온 시점에 가장 적은 연결 상태를 보이는 서버에 우선적으로 트래픽 배분
  - 최소 응답시간: 서버의 연결 상태와 응답시간을 모두 고려하여 트래픽을 배분

&nbsp;

### 11. ARP란 무엇인가요?

- IP 주소를 이용해 MAC 주소를 알아내는 프로토콜 → 논리적 주소를 물리적 주소로 변환하는 주소 결정 프로토콜
- 반대로 MAC 주소를 이용해 IP 주소를 알아내는 RARP도 있다.

1. 호스트 A가 호스트 B의 MAC 주소를 얻으려면 ARP Request라는 특수 패킷을 **브로드캐스팅**한다.
   - 브로드캐스팅을 지속적으로 하게 된다면 네트워크 트래픽이 증가해 CPU의 부담을 줄 수 있기 때문에 최근에 얻은 IP 주소와 MAC 주소를 매핑해 보관하는 캐시 정보를 이용한다.
2. 호스트 B가 아닌 다른 호스트들도 모두 패킷을 받게 되는데 관계가 없기 때문에 무시하고, 호스트 B는 ARP Reply 패킷을 통해 MAC 주소를 호스트 A에게 회신한다.

&nbsp;

### 12. MAC 주소란 무엇인가요?

- 네트워크 세그먼트의 데이터 링크 계층에서 통신을 위한 네트워크 인터페이스에 할당된 고유 식별자
- 네트워크 인터페이스 컨트롤러(NIC)의 제조업체가 할당하며 하드웨어에 저장된다.
- 총 48비트로 구성되어 있으며, 8비트씩 6자리로 구분하여 표기한다.
  - 앞의 3자리는 제조사 코드, 뒤의 3자리는 기기 고유 코드

&nbsp;

### 13. NAT란 무엇인가요?

- 네트워크 주소 변환(Network Address Translation)
- IP 패킷의 TCP/UDP 포트 숫자와 소스 및 목적지의 IP 주소 등을 재기록하면서 라우터를 통해 네트워크 트래픽을 주고 받는 기술
- 사설 네트워크에 속한 여러 개의 호스트가 하나의 공인 IP 주소를 사용하여 인터넷에 접속하기 위해 사용 → 공인 IP 주소를 절약할 수 있다.
  - 인터넷은 공인 IP로만 연결되어 통신이 가능하기 때문에 사설 IP 주소를 공인 IP 주소로 변환
- 공개된 인터넷 망은 외부에서 내부로의 해킹이나 침입의 위험이 있는데, 내부망과 공개망 사이에 방화벽을 운영하여 외부 공격으로부터 내부 인터넷망을 지킬 수 있다.

&nbsp;

## HTTP

### HTTP란 뭔가요?

- 하이퍼텍스트 전송 프로토콜
- 네트워크 장치 간에 정보를 전송하도록 설계된 애플리케이션 계층 프로토콜
- 서버와 클라이언트의 사이에서 어떻게 메시지를 교환할지 정해 놓은 규칙
- 요청과 응답으로 구성되어 있다.

&nbsp;

### HTTP 프로토콜의 가장 큰 특징은 뭔가요?

1. 클라이언트-서버 구조
   - 클라이언트는 서버에 요청을 보내고 응답이 올 때까지 대기
   - 서버는 클라이언트에서 받은 요청에 대한 결과를 만들어 응답
2. 무상태성(Stateless)
   - 서버가 클라이언트의 상태를 저장하지 않는다.
   - 서버가 클라이언트의 이전 상태(Context)를 저장하고 있지 않기 때문에, 클라이언트는 요청을 보낼 때 추가적인 데이터를 전송해야 한다.
   - 서버는 별도의 추가 정보를 관리하지 않아도 되고, 다수의 요청 처리 및 서버의 부하를 줄일 수 있다.
3. 비연결성(Connectionless)
   - 요청 후 응답을 받는 즉시 연결을 종료한다.
   - 서버 유지 자원을 효율적으로 사용할 수 있다.

&nbsp;

### URL은 뭔가요?

![URL 구성](./images/mdn_url_all.png)

- 웹에 게시된 리소스를 검색하기 위해 브라우저에서 사용하는 매커니즘
- 웹에서 주어진 고유 리소스 주소

1. 스키마: 브라우저가 리소스를 요청하는 데 사용해야 하는 프로토콜
2. 권한: `://`에 의해 스키마와 구분되며, 도메인과 포트가 포함된다.
   - 도메인: IP 주소도 사용될 수 있지만, 불편하기 때문에 일반적으로 도메인 이름을 사용한다.
   - 포트: 웹 서버의 리소스에 접근하는 데 사용되는 기술적인 게이트
3. 리소스 경로: 웹 초기에는 웹 서버의 실제 파일 위치를 나타냈으나, 요즘에는 물리적 실체가 없는 웹 서버가 추상적으로 처리
4. 매개변수: 웹 서버에 제공되는 추가 매개변수, `&` 기호로 구분된 키/값 쌍 목록
5. 앵커: 책갈피 역할을 하며, 브라우저가 해당 지점의 컨텐츠를 표시하도록 지시

&nbsp;

### HTTP/1.0 과 HTTP/1.1의 차이는 뭔가요?

- 연결 재사용: 단일 원본 문서 내로 포함된 리로스들을 표시하기 위해 더 이상 여러 번 연결을 열 필요가 없어졌다.
- 파이프라이닝 추가: 첫번째 요청에 대한 응답이 완전히 전송되기 전에 두번째 요청 전송이 가능해졌다. → 통신 지연 시간 단축
- 청크된 응답 지원

&nbsp;

### HTTP/1.1 과 HTTP/2.0의 차이는 뭔가요?

- 텍스트 프로토콜이 아닌 이진 프로토콜로, 읽을 수 없고 수동으로 만들 수도 없다.
- 다중 프로토콜로, 동일한 연결을 통해 병렬 요청을 수행할 수 있다.
- 헤더를 압축해 전송 데이터의 중복과 오버헤드가 제거된다.
- 서버가 서버 푸시라는 매커니즘을 통해 클라이언트 캐시에 데이터를 저장할 수 있다.

&nbsp;

### HTTPS는 HTTP랑 뭐가 다른가요?

- HTTP는 정보를 텍스트로 주고 받기 때문에 네트워크에서 전송 신호를 중간에서 탈취할 경우 데이터 유출이 발생할 수 있다. → 보안 취약점 해결을 위해 Secure Socket을 추가한 HTTPS가 등장
- 서버와 클라이언트 사이의 모든 통신 내용이 암호화된다. → SSL 또는 TLS 프로토콜을 통해 세션 데이터를 암호화하며, 기본 TCP/IP 포트는 443이다.

&nbsp;

### 심화) 공개키 (비대칭키) 방식이 뭔가요?

- HTTPS는 비대칭 암호화를 사용한다.
- 비대칭 암호화에는 두 개의 개별 키가 포함된다.
  - 하나의 키(공개 키)는 누구나 액세스할 수 있으며 암호화에 사용된다.
  - 두 번째 키(개인 키)는 수신자가 안전하게 보관하며 암호 해독에 사용된다.
- 비대칭 암호화는 대칭 암호화보다 느리지만 여러 사용자에게 키를 배포하기가 더 쉽다.

&nbsp;

## 운영체제

### 운영체제란 무엇인가요?

- 컴퓨터 시스템의 핵심 소프트웨어
- 컴퓨터 하드웨어와 응용 프로그램 간의 상효작용을 관리하고 제어하는 역할
- 사용자와 하드웨어 사이의 인터페이스를 제공해 효율적으로 응용프로그램이 동작하도록 지원
- 응용 프로그램이 원활하게 동작할 수 있도록 시스템 자원을 효율적으로 관리

&nbsp;

### 운영체제는 어떤 역할을 하나요?

1. 자원 관리
   - 컴퓨터 시스템의 하드웨어 자원을 효율적으로 관리
   - 여러 응용 프로그램이 동시에 실행될 수 있도록 CPU, 메모리, 저장장치 등 하드웨어의 자원을 할당/관리
2. 메모리 관리
   - 컴퓨터의 메모리를 효율적으로 관리하여 응용 프로그램이 필요로 하는 메모리 공간 할당
   - 메모리 할당과 해제, 가상메모리 관리 등
3. 프로세스 관리
   - 프로세스의 생성, 실행, 일시 정지, 시스템 중지 등의 작업 제어
   - 여러 프로세스 간의 자원 공유와 협력 관리
4. 디스크 및 파일 시스템 관리
   - 파일의 생성, 삭제, 복사, 이동 등의 작업 처리
   - 사용자 및 응용 프로그램이 데이터를 쉽게 관리할 수 있도록 데이터의 영구적인 저장과 접근을 제공
5. 입출력 관리
   - 입출력 장치와의 상호작용 관리
   - 입출력 장치의 성능을 최적화
6. 사용자 인터페이스
   - 사용자와 컴퓨터 간의 상호작용을 지원하는 사용자 인터페이스를 제공
   - 텍스트 기반의 터미널 환경(CLI)와 그래픽 사용자 환경(GUI)을 통해 사용자가 컴퓨터를 조작
7. 네트워킹
   - 컴퓨터 네트워크를 관리
   - 컴퓨터 간의 통신을 위한 네트워크 프로토콜을 지원
   - 인터넷 연결, 데이터 전송, 네트워크 보안 등을 관리
8. 오류 처리
   - 시스템 내/외부에서 발생하는 오류와 예외 상황을 처리
   - 프로세스의 비정상 종료, 메모리 오버플로우, 입출력 오류 등을 감지 및 처리
   - 시스템의 안정성과 신뢰성을 유지
9. 시스템 보안
   - 접근 제어, 사용자 인증, 암호화 등의 기능 제공
   - 불법적인 접근과 데이터 유출 등으로부터 시스템을 보호하고 안전한 환경을 제공

&nbsp;

### 운영체제는 어떤 구조로 이루어져 있나요?

![운영체제 구조](./images/architecture_of_os.gif)

- 인터페이스
  - 사용자의 명령을 컴퓨터에 전달하고 결과를 알려주는 소통 역할
  - GUI
  - CLI
- 커널
  - 컴퓨터 운영체제의 핵심이 되는 전반적인 프로그램
  - 프로세스 관리, 메모리 관리, 저장공간 관리, 연결된 장치 관리 등 컴퓨터에 속한 모든 자원을 관리하는 역할
- 시스템 콜
  - 커널을 보호하기 위해 만든 코드 집합
    - 사용자나 프로그램이 직접적으로 컴퓨터 자원에 접근하는 것을 막는다.
- 드라이버
  - 하드웨어 장치와 운영체제 간의 통신을 가능하게 하는 소프트웨어

&nbsp;

### 컴퓨터는 어떤 요소로 이루어져 있나요?

- CPU: 메모리에 저장된 명령어를 읽고, 해석/실행하는 역할
- 메모리: 현재 실행되는 프로그램의 명렁어와 데이터를 저장하는 요소
  - 명령어: 데이터를 움직이고 컴퓨터를 작동시키는 정보
  - 데이터: 컴퓨터가 이해하는 정적 정보(숫자, 문자, 이미지, 동영상 등)
- 보조기억장치: 물리적인 디스크가 연결되어 있는 기억 장치
  - 주 기억장치보다 느린 속도
  - 컴퓨터 전원을 끄더라도 저장된 데이터가 사라지지 않고 영구적으로 보관
- 입출력장치: 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환하는 장치

&nbsp;

### CPU는 어떤 요소로 이루어져 있나요?

- 제어장치(Control Unit): 프로세서의 조작을 지시
- 산술 논리장치(ALU, Arithmetic Logic Unit): 연산 작업, 논리 연산
- 레지스터(Register): CPU가 요청을 처리하는 데 필요한 데이터를 일시적으로 저장하는 기억장치
  - 메모리 주소 레지스터(MAR): 주소 버스에 주소를 출력하기 전에 임시 저장하는 레지스터
  - 프로그램 카운터(PC): 다음 인출할 명령어 주소를 임시 저장하는 레지스터
  - 메모리 버퍼 레지스터(MBR): 데이터 버스에 데이터를 읽고 쓰기 위해 잠시 저장해두는 버퍼 레지스터
  - 명령어 레지스터(IR): 가장 최근에 인출된 명령어를 임시 저장하는 레지스터
  - 누산기(AC): 중간 산술 논리 장치 결과를 임시 저장하는 레지스터

&nbsp;

### CPU는 어떻게 동작하나요?

| 명령어  | 설명                                                                        |
| ------- | --------------------------------------------------------------------------- |
| fetch   | 메모리로부터 명령어와 데이터를 프로세스로 가져오는 단계                     |
| decode  | 명령어를 분석해서 처리할 컨트롤 신호를 만드는 단계                          |
| execute | 컨트롤 신호에 따라 실제로 연산, 처리, 메모리 읽기 또는 쓰기를 실행하는 단계 |

1. CPU는 각 클럭마다 Fetch, Decode, Execute를 반복한다.
2. PC에 있는 주소값으로 명령어를 IR에 저장하고 (Fetch)
3. IR에 있는 명령어를 해석한 후 (Decode)
4. AC에 연산에 사용할 데이터를 저장한다. (Execute)
5. 위 과정을 반복

&nbsp;

### 메모리란 무엇인가요?

- 컴퓨터에서 정보 처리를 위해 일시적으로 정보를 보관하는 기억 장치
- 좁은 의미로는 주 기억장치인 램(RAM)을 의미하지만, 넓은 의미로는 보조기억장치인 롬(ROM)을 포함하기도 한다.
- 주 기억장치인 램(RAM)의 용량이 부족할 경우를 대비해 하드디스크의 일부를 가상메모리로 사용할 수도 있다.

&nbsp;

### 메모리는 어떤 계층 구조로 이루어져 있나요?

![메모리 계층 구조](./images/memory_hierarchy.png)

- 레지스터
  - CPU가 요청을 처리하는 데 필요한 데이터를 일시적으로 저장하는 기억장치
- 캐시
  - L1 캐시, L2 캐시
  - 데이터나 값을 미리 복사해 놓는 임시 장소
  - 시스템의 효율성을 위해 사용
  - 속도가 빠른 장치와 느린 장치 사이에서 속도 차에 따른 병목 현상을 완화하기 위한 범용 메모리
- 주기억장치
  - 컴퓨터에서 수치, 명령, 자료 등을 기억하는 컴퓨터 하드웨어 장치
- 보조기억장치
  - 비휘발성, 순차접근이 가능한 컴퓨터의 보조기억장치
  - 가장 대중적이며 용량 대비 가격이 저렴

&nbsp;

### 메모리는 어떤 방식으로 데이터를 관리하나요?

1. 연속 메모리 할당
   - 할당과 제거를 반복하다보면 외부 단편화가 발생
   - 외부 단편화를 줄이기 위한 할당 방식
     - 최초 적합: 가장 처음 만나는 빈 메모리 공간에 프로세스 할당
     - 최적 적합: 빈 메모리 공간의 크기와 프로세스의 크기 차이가 가장 적은 곳에 프로세스를 할당
     - 최악 적합: 빈 메모리 공간의 크기와 프로세스의 크기 차이가 가장 큰 곳에 프로세스를 할당
2. 페이징
   - 메모리 공간이 연속적으로 할다오디어야 한다는 제약조건을 없애는 메모리 관리 전략
   - 논리 메모리는 고정 크기의 페이지, 물리 메모리는 고정 크기의 프레임 블록으로 나누어 관리
   - 프로세스가 사용하는 공간을 논리 메모리에서 여러 개의 페이지로 나누어 관리하고, 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 매핑되어 저장
   - MMU(Memory Management Unit)의 재배치 레지스터 방식을 활용해 CPU가 마치 프로세스가 연속된 메모리에 할당된 것처럼 인식하도록 함
   - 내부 단편화 발생
3. 세그멘테이션
   - 페이징 기법과 반대로 논리 메모리에 물리 메모리를 같은 크기의 블록이 아닌, 서로 다른 크기의 논리적 단위인 세그먼트로 분할
   - 외부 단편화 발생
4. 세그멘테이션/페이징 혼용
   - 프로세스를 세그먼트로 나눈 다음 세그먼트를 다시 페이지 단위로 나누어 관리
   - 매핑 테이블을 두 번 거쳐야하므로 속도가 느려짐

[운영체제는 어떻게 메모리를 관리할까?](https://velog.io/@dongwookang/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC)

&nbsp;

## 프로세스와 스레드

### 프로세스가 뭔가요?

![프로세스](./images/process.png)

- 운영체제가 프로그램을 실행하기 위해 필요한 가장 작은 단위의 쓰레드, 메모리, 소스코드들의 집합
- 메모리에 올라와 실행되고 있는 프로그램의 인스턴스
- 각각 독립된 메모리 영역(Code, Data, Stack, Heap)을 할당받는다.
- 운영체제는 프로세스를 작업의 단위로 보고 자원들을 작업들에 적절히 분배
- 기본적으로 프로세스는 최소 1개의 스레드(메인 스레드)를 갖는다.

&nbsp;

### 스레드가 뭔가요?

![스레드](./images/thread.png)

- 프로세스 내에서 실행되는 여러 흐름의 단위
- 프로세스가 할당받은 자원을 이용하는 실행의 단위
- 스레드는 프로세스 내에서 각각 Stack만 할당받고, Code, Data, Heap 영역은 공유
  - 프로세스 내의 주소 공간(힙 공간 등)이나 자원들을 같은 프로세스 내에 스레드끼리 공유하면서 실행

&nbsp;

### 프로세스와 스레드는 어떤 차이가 있나요?

- 운영체제는 프로세스마다 각각 독립된 메모리 영역을 할당해주기 때문에 프로세스는 다른 프로세스의 변수나 자료에 접근할 수 없다.
  - 한 프로세스가 실행 중에 오류가 발생해서 프로세스가 강제 종료된다고 해도 다른 프로세스에 영향을 주지 않는다.
- 각각의 스레드는 별도의 스택을 가지고 있지만 힙 메모리는 서로 읽고 쓸 수 있다.
  - 스레드는 메모리 영역의 내용을 공유하기 때문에 어떤 스레드 하나에서 오류가 발생한다면 같은 프로세스 내의 다른 스레드 모두가 강제로 종료된다.

&nbsp;

### 프로세스의 컴파일 과정에 대해 설명해줄 수 있나요?

- 컴파일: 인간이 이해할 수 있는 언어로 작성된 소스 코드를 컴퓨터가 이해할 수 있는 언어로 변환하는 작업
- 전처리: 코드에서 주석을 제거하고 헤더 파일을 병합해 매크로를 치환
- 컴파일러: 오류 처리, 코드 최적화를 하고 어셈블리어로 변환
- 어셈블러: 어셈블리어는 목적 코드로 변환
- 링커: 프로그램 내에 있는 라이브러리/파일들과 목적 코드를 결합해서 실행파일 생성

&nbsp;

### 프로세스는 어떤 상태 값을 가지고 있나요?

![프로세스의 상태](./images/state_of_process.png)

- 생성 상태
  - 사용자가 요청한 작업이 커널에 등록되고 PCB가 할당돼 프로세스가 만들어진 상태
- 준비 상태
  - CPU를 할당 받기 위해 기다리고 있는 상태
- 준비 중단 상태
  - 생성된 프로세스가 바로 메모리를 받지 못할 때
  - 준비 또는 실행 상태에서 메모리를 잃게 될 때
- 실행 상태
  - CPU를 할당받아 실행 중인 상태
- 보류 상태
  - 프로세스가 실행되다가 입출력 처리를 요청하거나, 바로 확보될 수 없는 자원을 요청한 경우
  - CPU를 양도하고 요청한 일이 완료될 때까지 대기
- 일시 보류 상태
  - 대기 상태일 때 메모리 공간을 잃은 상태
- 종료 상태
  - 프로세스가 종료될 때 아주 잠깐 거치는 상태
  - 모든 자원이 회수되고 PCB를 삭제

&nbsp;

### 프로세스는 어떤 구조로 이루어져 있나요? (스택, 힙, 데이터 영역, 코드 영역)

![메모리 구조](./images/memory_structure.png)

- 스택: 임시 데이터(함수 호출, 로컬 변수 등)가 저장되는 영역
- 힙: 코드에서 동적으로 생성되는 데이터가 저장되는 영역
- 데이터: 전역 변수/초기화된 데이터가 저장되는 영역
  - BSS: 초기화되지 않은 전역 변수
  - DATA: 초기값이 있는 전역 변수
- 코드: 컴파일된 소스 코드가 저장되는 영역

&nbsp;

### PCB는 무엇인가요? 어떤 용도로 사용되나요? (메타 데이터)

- CPU는 프로세스의 상태에 따라서 교체 작업이 이루어진다.
  - 교체되는 프로세스의 상태 값을 PCB에 저장해두었다가 다시 수행할 때 사용
- 연결 리스트 방식으로 관리

![PCB](./images/pcb.png)

- Process ID
- Process State
- Program Counter
- CPU Register: CPU에서 사용한 레지스터의 값을 잃지 않기 위해 PCB에 값을 저장
- CPU Scheduling Information: 프로세스의 우선순위, 최종 실행 시간, 스케줄링 큐를 가리키는 포인터 등
- Memory management information: 레지스터, 페이지 테이블, 세그먼트 테이블의 base/limit 값에 대한 정보
- Accounting Information: CPU 사용 시간, 실제 사용된 시간, 시간 제한 등
- I/O Status Information: 프로세스에 할당된 I/O 기기에 해당하는 정보

&nbsp;

## 싱글 스레드와 멀티 스레드

### 싱글 스레드 장점

- 문맥 교환 작업을 요구하지 않는다.
- 자원 접근에 대한 동기화를 신경쓰지 않아도 된다.
- 단순히 CPU만을 사용하는 계산 작업이라면, 오히려 멀티 스레드보다 싱글 스레드로 프로그래밍하는 것이 더 효율적이다.
- 프로그래밍이 쉽고, CPU와 메모리를 적게 사용한다.

&nbsp;

### 싱글 스레드 단점

- 여러 개의 CPU를 활용하지 못한다.
- 연산량이 많은 작업의 경우, 그 작업이 완료되어야 다른 작업을 수행할 수 있다.
- 싱글 스레드 모델은 에러 처리를 못하는 경우 멈춘다.

&nbsp;

### 멀티 스레드 장점

- 응답성: 프로그램의 일부분이 중단되거나 긴 작업을 수행하더라도 프로그램의 수행이 계속되어 사용자에 대한 응답성 증가
  - 에러 발생 시 새로운 스레드를 생성해 극복
  - 새로운 스레드 생성이나 놀고있는 스레드 처리에 비용이 발생
- 경제성: 프로세스 내 자원들과 메모리를 공유하기 때문에 메모리 공간과 시스템 자원 소모가 줄어든다.
  - 스레드 간 통신이 필요한 경우에도 쉽게 데이터를 주고 받을 수 있다.
  - 프로세스의 문맥 교환과 달리 스레드 간의 문맥 교환은 캐시 메모리를 비울 필요가 없기 때문에 빠르다.
- 병렬성: 다중 CPU 구조에서는 각각의 스레드가 다른 프로세스에서 병렬로 수행될 수 있다.

&nbsp;

### 멀티 스레드 단점

- 문맥 교환, 동기화 등의 이유로 싱글 코어 멀티 스레딩은 스레드 생성 시간이 오히려 오버헤드로 작용해 싱글 스레드보다 느리다.
- 공유하는 자원에 동시에 접근하는 경우, 프로세스와 달리 스레드는 데이터와 힙 영역을 공유하기 때문에 어떤 스레드가 다른 스레드에서 사용 중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정할 수 있다.
  - 동기화가 필요하다.
- 멀티 스레딩을 위해서는 운영체제의 지원이 필요하다.
- 멀티 스레드 모델은 프로그래밍 난이도가 높고, 스레드 수만큼 자원을 많이 사용한다.

&nbsp;

## 공유 자원 임계 영역 교착 상태

### 공유 자원

- 시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 모니터, 프린터, 메모리, 파일, 데이터 등의 자원이나 변수 등
- 공유 자원을 두 개 이상의 프로세스가 동시에 읽거나 쓰는 상황을 **경쟁 상태(Race Condition)**이라고 한다.
  - 동시에 접근을 시도할 때 접근의 타이밍이나 순서 등이 결과에 영향을 줄 수 있는 상태

&nbsp;

### 임계 영역

- 둘 이상의 프로세스, 스레드가 공유 자원에 접근할 때 순서 등의 이유로 결과가 달라지는 코드 영역
- 이를 위한 방법으로는 뮤텍스, 세마포어, 모니터 등이 있다.
  - 잠금(lock) 메커니즘을 토대로 한다.
- 임계 영역을 해결하기 위해서는 세 가지 조건을 만족해야 한다.
  - 상호 배재: 한 프로세스가 임계 영역에 들어갔을 때 다른 프로세스는 들어갈 수 없다.
  - 한정 대기: 특정 프로세스가 영원히 임계 영역에 들어가지 못하면 안된다.
  - 융통성: 한 프로세스가 다른 프로세스의 일을 방해해서는 안된다.

&nbsp;

### 뮤텍스

- 공유 자원을 사용하기 전에 설정하고 사용한 후에는 해제하는 잠금
- 잠금이 설정되면 다른 스레드는 잠긴 코드 영역에 접근할 수 없다.
- 뮤텍스는 잠금 또는 잠금 해제 두 개의 상태만 가진다.
- 리소스에 대한 접근을 동기화하는 잠금 메커니즘

&nbsp;

### 세마포어

- 일반화된 뮤텍스
- `wait()`: 자신의 차례가 올 때까지 기다리는 함수
- `signal()`: 다음 프로세스로 순서를 넘겨주는 함수
- 신호를 이용해서 상호 배제가 일어나는 신호 메커니즘
  - 세마포어 자체가 `lock()`을 소유하는 개념이 아니기 때문에 프로세스가 세마포어를 해제할 수 있는 경우가 생긴다.

1. 프로세스가 공유 자원에 접근하면 세마포어에서 `wait()` 함수를 수행
2. 프로세스가 공유 자원을 다 사용해서 해제하면 세마포어에서 `signal()` 작업을 수행

&nbsp;

### 모니터

- 둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고, 해당 접근에 대한 인터페이스만 제공
  - 공유 데이터에 대한 캡슐화
- 접근하지 못한 스레드는 큐에 들어간 후 대기 상태로 전환

### 교착 상태

- 2개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태
- 원인 (4가지를 모두 충족해야 교착 상태가 발생한다.)
  - 상호 배제: 하나의 프로세스만이 자원을 사용할 수 있다.
  - 점유 대기: 자원을 가진 프로세스가 다른 자원을 기다릴 때, 보유하고 있는 자원을 놓지 않고 계속 가지고 있다.
  - 비선점: 프로세스는 OS에 의해 강제로 자원을 빼앗기지 않는다.
  - 환형 대기: 자원을 기다리는 프로세스 간에 사이클이 형성된다.

1. 예방
   - 교착 상태 발생 조건 중 하나를 제거
   - 자원의 낭비가 심하다.
2. 회피
   - 교착 상태 발생 시 피해나가는 방법
   - 은행원 알고리즘(뱅커 알고리즘)
     - [만화로 알아보는 은행원 알고리즘](https://velog.io/@minu-j/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%A7%8C%ED%99%94%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-%EC%9D%80%ED%96%89%EC%9B%90-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-%ED%9A%8C%ED%94%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)
3. 탐지
   - 자원 할당 그래프를 통해 교착 상태를 탐지
   - 자원 요청 시, 탐지 알고리즘을 실행시켜 그에 대한 오버헤드 발생
4. 회복
   - 교착 상태를 일으킨 프로세스를 종료하거나 할당된 자원을 해제시켜 회복시키는 방법

&nbsp;

## 쿠키 세션

### 쿠키, 세션을 왜 쓰나요?

- HTTP 프로토콜은 Connectionless, Stateless한 특성을 갖는다.
  - 이 특성을 보완하고자 쿠키와 세션을 사용

&nbsp;

### 쿠키가 뭔가요?

- HTTP의 일종
- 사용자가 웹 사이트를 방문할 경우, 해당 사이트가 사용하고 있는 서버에서 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일
  - HTTP에서 클라이언트의 상태 정보를 쿠키 형태로 클라이언트 PC에 저장했다가 필요 시 정보를 참조하거나 재사용할 수 있다.
- `key-value` 쌍으로 된 데이터 파일
- 쿠키 이름, 값, 만료 시간, 도메인, 경로, 보안 연결 여부, HttpOnly 여부로 구성
- 4KB(=4096byte)까지 저장 가능
- 쿠키는 클라이언트에서 수정할 수 있기 때문에, 쿠키값을 암호화해야 하며 민감하거나 중요한 정보를 담지 않아야 한다.

|     쿠키 종류      |                                                  특징                                                  |
| :----------------: | :----------------------------------------------------------------------------------------------------: |
|   Session Cookie   |     일반적으로 만료시간(Expire Date)를 설정하고 메모리에만 저장되며, 브라우저 종료 시 쿠키를 삭제      |
| Persistent Cookie  |                장기간 유지되는 쿠키, 파일로 저장되어 브라우저 종료와 관계없이 사용 가능                |
|   Secure Cookie    |                         HTTPS 프로토콜에서만 사용, 쿠키 정보가 암호화되어 전송                         |
| Third-Party Cookie | 방문한 도메인과 다른 도메인의 쿠키, 일반적으로 광고 배너 등을 관리할 때 유입 경로를 추적하기 위해 사용 |

&nbsp;

### 세션이 뭔가요?

- 웹 브라우저를 통해 웹 서버에 접속한 시점부터 웹 브라우저를 종료하여 연결을 끝내는 시점까지 같은 사용자로부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를 유지시키는 기술
- 웹 서버에 웹 컨테이너의 상태를 유지하기 위한 정보를 저장
- 웹 서버에 저장되는 쿠키(Session Cookie)
- 브라우저를 닫거나, 서버에서 세션을 삭제했을 때만 삭제가 되기 때문에 쿠키에 비해 보안적으로 우수
- 서버 용량 허용 범위 내에서 저장 데이터의 크기 제한이 없다.
- 각 클라이언트에 고유 세션 ID를 부여
- 서버에 부하가 발생할 수 있으며, 쿠키에 비해 비교적 느리다.

&nbsp;

### 쿠키와 세션의 차이는 어떤 점이 있을까요?

1. 쿠키는 클라이언트의 웹 브라우저가 지정하는 메모리 또는 하드디스크에 저장되는 반면, 세션은 서버의 메모리에 저장된다.
2. 쿠키는 저장할 때 expires 속성을 정의해 무효화시키면 삭제될 날짜를 지정할 수 있지만, 세션은 클라이언트가 로그아웃하거나 설정 시간동안 반응이 없을 때 무효화되어 정확한 시점을 알 수 없다.
3. 쿠키는 클라이언트에 저장되고 클라이언트의 메모리를 사용하기 때문에 서버 자원을 사용하지 않지만, 세션은 서버에 저장되고 서버의 메모리로 로딩되기 때문에 세션이 생길 때마다 리소스를 차지한다.
4. 쿠키는 한 도메인 당 20개, 한 개의 쿠키 당 4KB로 제한돼있지만, 세션은 개수나 용량의 제한이 없다.
5. 쿠키는 세션에 비해 속도가 빠르다.

&nbsp;

### JWT을 아나요?

- 유저를 인증하고 식별하기 위한 토큰 기반 인증
- 토큰 자체에 사용자의 권한 정보나 서비스를 사용하기 위한 정보가 포함된다.
- RESTful과 같은 무상태인 환경에서 사용자 데이터를 주고받을 수 있게 된다.
- JWT는 Header, Payload, Signature 세 파트로 나누어지며, 각 파트는 점으로 구분하여 표현한다.
  - Header: 서명 시 사용하는 키(kid), 타입(typ), 암호화 알고리즘의 정보(alg)가 담겨있다.
  - Payload: 토큰에서 사용할 정보의 조각들인 클레임(Claim)이 담겨있다.
    - 클레임은 Key/Value 형태로 된 값을 가진다.
      - iss: 토큰 발급자(issuer) - Public Claims
      - sub: 토큰 제목(subject) - Public Claims
      - iat: 토큰 발급 시간(issued at) - Public Claims
      - exp: 토큰 만료 시간(expiration) - Public Claims
      - roles: 권한 - Private Claims
  - Signature: 헤더에서 정의한 알고리즘 방식을 활용
    - 헤더+페이로드와 서버가 갖고 있는 유일한 key 값을 합친 것을 헤더에서 정의한 알고리즘으로 암호화
    - 헤더와 페이로드는 단순히 인코딩된 값으로 제 3자가 복호화 및 조작할 수 있지만, 서명은 서버 측에서 관리하는 비밀키가 유출되지 않는 이상 복호화할 수 없다.
      - 토큰 위변조 여부 확인에 사용

&nbsp;

### JWT를 웹 스토리지에 저장해야 한다면 어디다 저장하시겠나요? 이유는요?

> [!CAUTION]
> 지극히 개인적인 생각입니다!

- (웹 스토리지 자체가 JS로 접근이 가능하기 때문에 보안적으로 우수하지는 않지만,) 보안이 중요해서 자주 로그아웃 처리를 해줘야 하는 경우에는 세션 스토리지에, 일반적인 경우에는 로컬 스토리지에 저장할 것 같다.
- 웹 스토리지에는 로컬 스토리지와 세션 스토리지가 있다. (쿠키에 저장하고 싶지만, 쿠키는 웹 스토리지가 아니다.)
  - 로컬 스토리지는 데이터를 영구적으로 저장할 수 있지만, 세션 스토리지는 브라우저 탭/윈도우가 닫히면 초기화된다.
  - 로컬 스토리지는 같은 도메인일 경우 데이터가 공유되지만, 세션 스토리지는 탭이나 창을 구분하여 저장된다.
- 쿠키에 저장하고 싶은 이유는?
  - 별도로 처리하지 않아도 헤더에 쿠키가 삽입되기 때문에 서버와 소통이 간단하다.
  - 쿠키의 도메인 속성을 통해 다양한 하위 서비스와 인증 정보를 공유할 수 있다.
  - HttpOnly 쿠키로 XSS 공격에 대응할 수 있다.
  - 서버에서 Spring Security 등을 사용하는 경우 CSRF 토큰에 대한 옵션을 제공하기 때문에 CSRF 공격에 대해서도 보안 수준을 높일 수 있다.

&nbsp;

## CORS

### CORS가 뭔가요?

- Cross Origin Resource Sharing, 교차 출처 자원 공유
  - Origin(출처): 프로토콜 + 도메인 + 포트
- 서버가 다른 출처로부터의 액세스를 허용하거나 제한할 수 있게 하는 HTTP 헤더 기반의 메커니즘
- 예전에는 프론트엔드와 백엔드를 따로 구성하지 않고 한 번에 구성해서 모든 처리가 같은 도메인 안에서 가능했다.
  - 다른 출처로 요청을 보내는 것을 의심스러운 행위로 보는 것이 당연했다.
- 시간이 지나 클라이언트에서 API를 직접 호출하는 방식이 당연해지기 시작했다.
  - 클라이언트와 API는 다른 도메인에 있는 경우가 많고, 그래서 CORS 정책이 생기게 되었다.
    - 출처가 다르더라도 요청과 응답을 주고받을 수 있도록 서버에 리소스 호출이 허용된 출처(Origin)를 명시해 주는 방식

&nbsp;

### CORS를 겪고 직접 해결해 본 경험이 있으면 말해주세요.

1. 서버에서 `Access-Control-Allow-Origin` 응답 헤더 설정하기
   - 서버에서 헤더를 설정해서 요청을 수락할 출처를 명시적으로 지정
   - 클라이언트에서 `withCredentials` 설정하기 - Axios를 사용하는 경우
2. 프록시 서버 사용하기

&nbsp;

## 개발 방법론

### 소프트웨어 개발 주기(SDLC)에 대해 아나요?

- Software Development Life Cycle
- 개발 팀이 고품질 소프트웨어를 설계하고 구축하는 데 사용하는 비용 효율적이고 시간 효율적인 프로세스

1. 요구사항 분석
   - 비용 편익 분석, 스케줄링, 리소스 추정, 할당 등의 작업
   - 여러 이해 관계자의 요구 사항을 수집하여 소프트웨어 요구 사항 사양 문서를 작성
2. 설계
   - 요구 사항을 분석하고 소프트웨어를 만들기 위한 최적의 솔루션 탐색
     - 기존 모듈 통합, 기술 선정, 개발 도구 탐색 등
3. 개발
   - 코딩
4. 테스트
   - 자동화 및 수동 테스트를 결합해 소프트웨어의 버그를 확인
   - 품질 분석(소프트웨어에 오류가 있는지 테스트 + 고객 요구 사항을 충족하는지 확인)
5. 운영
   - 배포: 소프트웨어가 변경되거나 업그레이드되는 동안에도 고객이 소프트웨어를 계속 사용할 수 있도록 빌드 환경과 프로덕션 환경을 별도 구축
   - 유지 관리: 버그를 수정하고 고객 문제를 해결하며 소프트웨어 변경 사항을 관리

&nbsp;

### 폭포수 방법론이란 뭔가요?

![waterfall](./images/waterfall.jpg)

- 새로운 단계가 이전 단계의 결과에 따라 달라지도록 모든 단계를 순차적으로 배열
- 개념적으로, 폭포처럼 한 단계에서 다음 단계로 흐른다.

&nbsp;

### 애자일 방법론이란 뭔가요?

![agile](./images/agile.png)

- SDLC 단계를 여러 개발 주기로 나누고, 팀은 각 주기에서 작은 증분 소프트웨어 변경만 제공하면서 단계를 빠르게 반복
- 요구 사항, 계획 및 결과를 지속적으로 평가하여 변화에 신속하게 대응

&nbsp;

## Cache

### 캐시란 무엇인가요?

- 자주 사용하는 데이터나 값을 미리 복사해 놓는 임시 장소 → 휘발성
- 저장 공간이 작고 비용이 비싼 대신 빠른 성능을 제공
- 파레토 / 롱테일 법칙: 20%의 요구가 시스템 리소스의 대부분을 사용한다.
- 시간적 지역성: 가까운 미래에 한 번 더 데이터에 접근할 가능성이 높은 경우
- 공간적 지역성: 특정 데이터와 가까운 순서대로 접근되었을 경우

&nbsp;

## CDN

### CDN이란 뭔가요?

- 지리적으로 분산된 서버들을 연결한 네트워크 → 에지 서버(Edge Server)
- 웹 컨텐츠의 복사본을 사용자에 가까운 곳에 두거나 동적 컨텐츠의 전달을 활성화하여 웹 성능 및 속도를 향상
- 사용자가 경험하는 로딩 시간을 단축
- 대역폭 소비 및 비용을 관리

&nbsp;

## 테스트

### 테스트란 무엇인가요?

- 프로그램을 실행하는 경우에 요구 사항에 맞춰 동작하는지 검증하는 행위

&nbsp;

### 테스트의 예는 어떤 것들이 있나요?

- 버튼을 클릭했을 때 웹사이트의 기능이 올바르게 작동하는지 확인
- 복잡한 함수가 올바른 결과를 생성하는지 확인
- 사용자 로그인이 필요한 작업 확인
- 잘못된 형식의 데이터를 입력했을 때 양식에 오류가 제대로 보고되는지 확인

&nbsp;

### 테스트는 왜 해야 하나요?

- 디버깅 비용 절감
  - 서비스를 운영하다보면 문제를 해결하는 시간보다 문제를 찾기 위한 시간이 더 많다.
  - 테스트 코드를 통해 오류를 줄일 수 있고 빠르게 대처할 수 있는 내성이 생긴다.
- 코드 변경에 대한 불안감 해소
  - 하나의 기능을 수정할 때 구성된 요소가 다른 기능과도 협력하고 있고 영향을 주기 때문에 회귀 버그가 생긴다.
- 더 나은 문서 자료
  - 테스트를 작성할 때 명세를 작성하면서 실제 동작을 기술함으로써 이 코드가 어떤 역할을 가졌는지 이해하는데 도움을 준다.
